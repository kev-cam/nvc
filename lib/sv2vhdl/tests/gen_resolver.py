#!/usr/bin/env python3
"""
gen_resolver.py -- Generate resolver network VHDL from design connectivity

The resolver is regular VHDL between inputs and outputs:
  - Inputs:  'driver signals from tran entities (logic3ds)
             + regular assign values (std_logic, converted to logic3ds)
  - Outputs: 'other signals for each tran endpoint (logic3ds)

For each net with N drivers, each endpoint i gets:
    other(i) = resolve(all drivers except i)
For N=2 this is a simple swap.

Usage:
    python3 gen_resolver.py
"""

from dataclasses import dataclass, field
from typing import Optional


@dataclass
class Endpoint:
    """One driver on a net."""
    kind: str           # "tran_port" or "assign"
    instance: str       # e.g. "gen_chain(1).tc" for tran; "" for assign
    entity: str         # e.g. "sv_tran"
    arch: str           # e.g. "strength"
    port: str           # e.g. "a", "b" for tran; "" for assign
    source_expr: str    # for assigns: source signal name (e.g. "a")
    str_one: int = 8    # strength when driving 1 (l3ds_strength)
    str_zero: int = 8   # strength when driving 0 (l3ds_strength)
    comment: str = ""   # e.g. "(supply1, strong0)"

    @property
    def has_implicit(self):
        """Whether this endpoint uses 'driver/'other."""
        return self.kind == "tran_port"


@dataclass
class Net:
    """A resolved net with multiple endpoints."""
    name: str
    sig_type: str = "std_logic"
    endpoints: list = field(default_factory=list)


# Strength constants (must match logic3ds_pkg)
ST_HIGHZ  = 0
ST_WEAK   = 2
ST_PULL   = 4
ST_STRONG = 8
ST_SUPPLY = 16

STR_MAP = {
    "supply": ST_SUPPLY, "strong": ST_STRONG,
    "pull": ST_PULL, "weak": ST_WEAK, "highz": ST_HIGHZ,
}
STR_VHDL = {
    ST_SUPPLY: "ST_SUPPLY", ST_STRONG: "ST_STRONG",
    ST_PULL: "ST_PULL", ST_WEAK: "ST_WEAK", ST_HIGHZ: "ST_HIGHZ",
}


def build_test_tran_str():
    """Build connectivity model for test_tran_str (translation of tran.v)."""
    nets = []
    str_names = ["supply", "strong", "pull", "weak", "highz"]

    # --- Chain: ac(1) through ac(7) ---
    ac1 = Net("ac(1)")
    ac1.endpoints.append(Endpoint(
        "assign", "", "", "", "", "a",
        ST_SUPPLY, ST_SUPPLY, "(supply1, supply0)"))
    ac1.endpoints.append(Endpoint(
        "tran_port", "gen_chain(1).tc", "sv_tran", "strength", "a", ""))
    nets.append(ac1)

    for i in range(2, 7):
        net = Net(f"ac({i})")
        net.endpoints.append(Endpoint(
            "tran_port", f"gen_chain({i-1}).tc", "sv_tran", "strength", "b", ""))
        net.endpoints.append(Endpoint(
            "tran_port", f"gen_chain({i}).tc", "sv_tran", "strength", "a", ""))
        nets.append(net)

    ac7 = Net("ac(7)")
    ac7.endpoints.append(Endpoint(
        "tran_port", "gen_chain(6).tc", "sv_tran", "strength", "b", ""))
    nets.append(ac7)

    # --- Grid: ag(k), bg(k) for k=1..25 ---
    for i in range(1, 6):
        for j in range(1, 6):
            k = (i - 1) * 5 + j
            inst = f"gen_row({i}).gen_col({j}).t_grid"
            s1 = STR_MAP[str_names[i - 1]]
            s0 = STR_MAP[str_names[j - 1]]
            comment = f"({str_names[i-1]}1, {str_names[j-1]}0)"

            ag = Net(f"ag({k})")
            if not (i == 5 and j == 5):
                ag.endpoints.append(Endpoint(
                    "assign", "", "", "", "", "a", s1, s0, comment))
            ag.endpoints.append(Endpoint(
                "tran_port", inst, "sv_tran", "strength", "a", ""))
            nets.append(ag)

            bg = Net(f"bg({k})")
            if not (i == 5 and j == 5):
                bg.endpoints.append(Endpoint(
                    "assign", "", "", "", "", "b", s1, s0, comment))
            bg.endpoints.append(Endpoint(
                "tran_port", inst, "sv_tran", "strength", "b", ""))
            nets.append(bg)

    return "test_tran_str", nets


def emit_resolver_vhdl(design_name, nets):
    """Generate resolver VHDL with actual resolution processes."""
    lines = []
    wrapper = f"resolved_{design_name}"

    # Classify nets
    active_nets = [n for n in nets if len(n.endpoints) > 1]
    tran_tran = [n for n in active_nets
                 if all(e.has_implicit for e in n.endpoints)]
    assign_tran = [n for n in active_nets
                   if any(not e.has_implicit for e in n.endpoints)]
    leaf_nets = [n for n in nets if len(n.endpoints) == 1]

    lines.append(f"-- Resolver networks for {design_name}")
    lines.append(f"-- Auto-generated by gen_resolver.py")
    lines.append(f"--")
    lines.append(f"-- {len(active_nets)} nets needing resolution:")
    lines.append(f"--   {len(tran_tran)} tran<->tran  (swap 'driver/'other)")
    lines.append(f"--   {len(assign_tran)} assign+tran (regular driver + implicit)")
    lines.append(f"--   {len(leaf_nets)} leaf nets (no resolution)")
    lines.append(f"--")
    lines.append(f"-- Resolver is regular VHDL: reads driver signals, writes 'other signals.")
    lines.append(f"-- For each endpoint i on a net: other(i) = resolve(all drivers except i)")
    lines.append(f"--")
    lines.append(f"-- NOTE: Regular assigns (ag <= a) also drive the std_logic net directly.")
    lines.append(f"-- The tran entity's inout port currently drives 'U' (no normal driver).")
    lines.append(f"-- Replumbing needed: either NVC uses 'driver as the port's actual driver,")
    lines.append(f"-- or the assign is removed from the DUT and handled entirely by resolver.")
    lines.append(f"")

    # --- Connectivity detail as comments ---
    lines.append(f"-- ====================================================================")
    lines.append(f"-- Net connectivity")
    lines.append(f"-- ====================================================================")
    for net in active_nets:
        parts = []
        for ep in net.endpoints:
            if ep.kind == "assign":
                parts.append(f"assign({ep.source_expr}) {ep.comment}")
            else:
                parts.append(f"{ep.instance}.{ep.port}")
        lines.append(f"-- {net.name}: {' <-> '.join(parts)}")
    lines.append(f"")

    # --- Entity ---
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    lines.append(f"use work.logic3ds_pkg.all;")
    lines.append(f"")
    lines.append(f"entity resolver_{design_name} is")
    lines.append(f"end entity;")
    lines.append(f"")
    lines.append(f"architecture generated of resolver_{design_name} is")
    lines.append(f"")

    # --- External names: source signals for regular assigns ---
    source_sigs = set()
    for net in active_nets:
        for ep in net.endpoints:
            if ep.kind == "assign":
                source_sigs.add(ep.source_expr)

    if source_sigs:
        lines.append(f"    -- Source signals for regular assigns (read from DUT)")
        for sig in sorted(source_sigs):
            lines.append(f"    alias src_{sig} is"
                         f" << signal .{wrapper}.dut.{sig} : std_logic >>;")
        lines.append(f"")

    # --- External names: 'driver/'other for tran endpoints ---
    lines.append(f"    -- Implicit signals inside tran instances")
    lines.append(f"    -- drv_N = 'driver (what tran drives onto net)")
    lines.append(f"    -- oth_N = 'other (what tran sees from all other drivers)")

    alias_map = {}  # (net_name, ep_index) -> (drv_alias, oth_alias)
    alias_idx = 0

    for net in nets:
        for i, ep in enumerate(net.endpoints):
            if not ep.has_implicit:
                continue
            drv = f"drv_{alias_idx}"
            oth = f"oth_{alias_idx}"
            # External name path uses '.' separator throughout.
            # NVC resolves .signal.DRIVER -> signal$driver (implicit signal)
            # and .signal.OTHER -> signal$other.
            inst_path = ep.instance
            port_lower = ep.port
            lines.append(f"    -- {net.name}: {ep.instance}.{ep.port}")
            lines.append(f"    alias {drv} is << signal"
                         f" .{wrapper}.dut.{inst_path}"
                         f".{port_lower}.driver : logic3ds >>;")
            lines.append(f"    alias {oth} is << signal"
                         f" .{wrapper}.dut.{inst_path}"
                         f".{port_lower}.other : logic3ds >>;")
            alias_map[(net.name, i)] = (drv, oth)
            alias_idx += 1

    lines.append(f"")

    # --- Helper function for asymmetric strength conversion ---
    lines.append(f"    -- Convert std_logic to logic3ds with asymmetric strengths")
    lines.append(f"    -- Models Verilog: assign (str1, str0) y = d;")
    lines.append(f"    function to_logic3ds_asym(")
    lines.append(f"        val : std_logic; str1, str0 : l3ds_strength")
    lines.append(f"    ) return logic3ds is")
    lines.append(f"    begin")
    lines.append(f"        case val is")
    lines.append(f"            when '1' | 'H' => return l3ds_drive(true, str1);")
    lines.append(f"            when '0' | 'L' => return l3ds_drive(false, str0);")
    lines.append(f"            when 'Z'       => return L3DS_Z;")
    lines.append(f"            when others     =>")
    lines.append(f"                if str_gt(str1, str0) then")
    lines.append(f"                    return make_logic3ds(0, str1, FL_UNKNOWN);")
    lines.append(f"                else")
    lines.append(f"                    return make_logic3ds(0, str0, FL_UNKNOWN);")
    lines.append(f"                end if;")
    lines.append(f"        end case;")
    lines.append(f"    end function;")
    lines.append(f"")

    lines.append(f"begin")
    lines.append(f"")

    # --- Resolution processes ---

    # tran<->tran: simple swap
    if tran_tran:
        lines.append(f"    ---------------------------------------------------------------")
        lines.append(f"    -- tran <-> tran: swap 'driver/'other")
        lines.append(f"    ---------------------------------------------------------------")
        for net in tran_tran:
            ep0 = net.endpoints[0]
            ep1 = net.endpoints[1]
            drv0, oth0 = alias_map[(net.name, 0)]
            drv1, oth1 = alias_map[(net.name, 1)]

            lines.append(f"    -- {net.name}: "
                         f"{ep0.instance}.{ep0.port} <-> "
                         f"{ep1.instance}.{ep1.port}")
            lines.append(f"    {oth0} <= {drv1};")
            lines.append(f"    {oth1} <= {drv0};")
            lines.append(f"")

    # assign+tran: convert assign value, feed to tran's 'other
    if assign_tran:
        lines.append(f"    ---------------------------------------------------------------")
        lines.append(f"    -- assign + tran: regular driver feeds tran 'other")
        lines.append(f"    ---------------------------------------------------------------")
        for net in assign_tran:
            assign_ep = [e for e in net.endpoints if e.kind == "assign"][0]
            tran_idx = next(i for i, e in enumerate(net.endpoints)
                           if e.kind == "tran_port")
            tran_ep = net.endpoints[tran_idx]
            drv_t, oth_t = alias_map[(net.name, tran_idx)]
            s1 = STR_VHDL[assign_ep.str_one]
            s0 = STR_VHDL[assign_ep.str_zero]
            src = f"src_{assign_ep.source_expr}"

            lines.append(f"    -- {net.name}: assign({assign_ep.source_expr})"
                         f" {assign_ep.comment} -> "
                         f"{tran_ep.instance}.{tran_ep.port}")
            lines.append(f"    {oth_t} <= to_logic3ds_asym({src}, {s1}, {s0});")
            lines.append(f"")

    lines.append(f"end architecture;")
    lines.append(f"")

    # --- Wrapper ---
    lines.append(f"-- Wrapper: instantiates DUT + resolver for standalone simulation")
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    lines.append(f"")
    lines.append(f"entity {wrapper} is end;")
    lines.append(f"architecture wrapper of {wrapper} is")
    lines.append(f"begin")
    lines.append(f"    dut: entity work.{design_name};")
    lines.append(f"    resolver: entity work.resolver_{design_name};")
    lines.append(f"end architecture;")
    lines.append(f"")

    return "\n".join(lines)


def main():
    import sys
    design_name, nets = build_test_tran_str()
    vhdl = emit_resolver_vhdl(design_name, nets)
    outfile = f"resolver_{design_name}.vhd"
    with open(outfile, "w") as f:
        f.write(vhdl)
    print(vhdl)
    print(f"\n-- Written to {outfile}", file=sys.stderr)


if __name__ == "__main__":
    main()
