-- Resolver networks for test_tran_str
-- Auto-generated by gen_resolver.py
--
-- All writes use deposit (:=) inside processes.
-- 54 nets needing resolution:
--   5 tran<->tran  (swap 'driver/'other)
--   49 assign+tran (regular driver + implicit)
--   3 leaf nets (no resolution)
--   57 nets needing receiver deposit

-- ====================================================================
-- Net connectivity
-- ====================================================================
-- ac(1): assign(a) (supply1, supply0) <-> gen_chain(1).tc.a
-- ac(2): gen_chain(1).tc.b <-> gen_chain(2).tc.a
-- ac(3): gen_chain(2).tc.b <-> gen_chain(3).tc.a
-- ac(4): gen_chain(3).tc.b <-> gen_chain(4).tc.a
-- ac(5): gen_chain(4).tc.b <-> gen_chain(5).tc.a
-- ac(6): gen_chain(5).tc.b <-> gen_chain(6).tc.a
-- ag(1): assign(a) (supply1, supply0) <-> gen_row(1).gen_col(1).t_grid.a
-- bg(1): assign(b) (supply1, supply0) <-> gen_row(1).gen_col(1).t_grid.b
-- ag(2): assign(a) (supply1, strong0) <-> gen_row(1).gen_col(2).t_grid.a
-- bg(2): assign(b) (supply1, strong0) <-> gen_row(1).gen_col(2).t_grid.b
-- ag(3): assign(a) (supply1, pull0) <-> gen_row(1).gen_col(3).t_grid.a
-- bg(3): assign(b) (supply1, pull0) <-> gen_row(1).gen_col(3).t_grid.b
-- ag(4): assign(a) (supply1, weak0) <-> gen_row(1).gen_col(4).t_grid.a
-- bg(4): assign(b) (supply1, weak0) <-> gen_row(1).gen_col(4).t_grid.b
-- ag(5): assign(a) (supply1, highz0) <-> gen_row(1).gen_col(5).t_grid.a
-- bg(5): assign(b) (supply1, highz0) <-> gen_row(1).gen_col(5).t_grid.b
-- ag(6): assign(a) (strong1, supply0) <-> gen_row(2).gen_col(1).t_grid.a
-- bg(6): assign(b) (strong1, supply0) <-> gen_row(2).gen_col(1).t_grid.b
-- ag(7): assign(a) (strong1, strong0) <-> gen_row(2).gen_col(2).t_grid.a
-- bg(7): assign(b) (strong1, strong0) <-> gen_row(2).gen_col(2).t_grid.b
-- ag(8): assign(a) (strong1, pull0) <-> gen_row(2).gen_col(3).t_grid.a
-- bg(8): assign(b) (strong1, pull0) <-> gen_row(2).gen_col(3).t_grid.b
-- ag(9): assign(a) (strong1, weak0) <-> gen_row(2).gen_col(4).t_grid.a
-- bg(9): assign(b) (strong1, weak0) <-> gen_row(2).gen_col(4).t_grid.b
-- ag(10): assign(a) (strong1, highz0) <-> gen_row(2).gen_col(5).t_grid.a
-- bg(10): assign(b) (strong1, highz0) <-> gen_row(2).gen_col(5).t_grid.b
-- ag(11): assign(a) (pull1, supply0) <-> gen_row(3).gen_col(1).t_grid.a
-- bg(11): assign(b) (pull1, supply0) <-> gen_row(3).gen_col(1).t_grid.b
-- ag(12): assign(a) (pull1, strong0) <-> gen_row(3).gen_col(2).t_grid.a
-- bg(12): assign(b) (pull1, strong0) <-> gen_row(3).gen_col(2).t_grid.b
-- ag(13): assign(a) (pull1, pull0) <-> gen_row(3).gen_col(3).t_grid.a
-- bg(13): assign(b) (pull1, pull0) <-> gen_row(3).gen_col(3).t_grid.b
-- ag(14): assign(a) (pull1, weak0) <-> gen_row(3).gen_col(4).t_grid.a
-- bg(14): assign(b) (pull1, weak0) <-> gen_row(3).gen_col(4).t_grid.b
-- ag(15): assign(a) (pull1, highz0) <-> gen_row(3).gen_col(5).t_grid.a
-- bg(15): assign(b) (pull1, highz0) <-> gen_row(3).gen_col(5).t_grid.b
-- ag(16): assign(a) (weak1, supply0) <-> gen_row(4).gen_col(1).t_grid.a
-- bg(16): assign(b) (weak1, supply0) <-> gen_row(4).gen_col(1).t_grid.b
-- ag(17): assign(a) (weak1, strong0) <-> gen_row(4).gen_col(2).t_grid.a
-- bg(17): assign(b) (weak1, strong0) <-> gen_row(4).gen_col(2).t_grid.b
-- ag(18): assign(a) (weak1, pull0) <-> gen_row(4).gen_col(3).t_grid.a
-- bg(18): assign(b) (weak1, pull0) <-> gen_row(4).gen_col(3).t_grid.b
-- ag(19): assign(a) (weak1, weak0) <-> gen_row(4).gen_col(4).t_grid.a
-- bg(19): assign(b) (weak1, weak0) <-> gen_row(4).gen_col(4).t_grid.b
-- ag(20): assign(a) (weak1, highz0) <-> gen_row(4).gen_col(5).t_grid.a
-- bg(20): assign(b) (weak1, highz0) <-> gen_row(4).gen_col(5).t_grid.b
-- ag(21): assign(a) (highz1, supply0) <-> gen_row(5).gen_col(1).t_grid.a
-- bg(21): assign(b) (highz1, supply0) <-> gen_row(5).gen_col(1).t_grid.b
-- ag(22): assign(a) (highz1, strong0) <-> gen_row(5).gen_col(2).t_grid.a
-- bg(22): assign(b) (highz1, strong0) <-> gen_row(5).gen_col(2).t_grid.b
-- ag(23): assign(a) (highz1, pull0) <-> gen_row(5).gen_col(3).t_grid.a
-- bg(23): assign(b) (highz1, pull0) <-> gen_row(5).gen_col(3).t_grid.b
-- ag(24): assign(a) (highz1, weak0) <-> gen_row(5).gen_col(4).t_grid.a
-- bg(24): assign(b) (highz1, weak0) <-> gen_row(5).gen_col(4).t_grid.b

library ieee;
use ieee.std_logic_1164.all;
use work.logic3ds_pkg.all;

entity resolver_test_tran_str is
end entity;

architecture generated of resolver_test_tran_str is

    -- Source signals for regular assigns (read from DUT)
    alias src_a is << signal .resolved_test_tran_str.dut.a : std_logic >>;
    alias src_b is << signal .resolved_test_tran_str.dut.b : std_logic >>;

    -- Implicit signals inside tran instances
    -- drv_N = 'driver (what tran drives onto net)
    -- oth_N = 'other (what tran sees from all other drivers)
    -- ac(1): gen_chain(1).tc.a
    alias drv_0 is << signal .resolved_test_tran_str.dut.gen_chain(1).tc.a.driver : logic3ds >>;
    alias oth_0 is << signal .resolved_test_tran_str.dut.gen_chain(1).tc.a.other : logic3ds >>;
    -- ac(2): gen_chain(1).tc.b
    alias drv_1 is << signal .resolved_test_tran_str.dut.gen_chain(1).tc.b.driver : logic3ds >>;
    alias oth_1 is << signal .resolved_test_tran_str.dut.gen_chain(1).tc.b.other : logic3ds >>;
    -- ac(2): gen_chain(2).tc.a
    alias drv_2 is << signal .resolved_test_tran_str.dut.gen_chain(2).tc.a.driver : logic3ds >>;
    alias oth_2 is << signal .resolved_test_tran_str.dut.gen_chain(2).tc.a.other : logic3ds >>;
    -- ac(3): gen_chain(2).tc.b
    alias drv_3 is << signal .resolved_test_tran_str.dut.gen_chain(2).tc.b.driver : logic3ds >>;
    alias oth_3 is << signal .resolved_test_tran_str.dut.gen_chain(2).tc.b.other : logic3ds >>;
    -- ac(3): gen_chain(3).tc.a
    alias drv_4 is << signal .resolved_test_tran_str.dut.gen_chain(3).tc.a.driver : logic3ds >>;
    alias oth_4 is << signal .resolved_test_tran_str.dut.gen_chain(3).tc.a.other : logic3ds >>;
    -- ac(4): gen_chain(3).tc.b
    alias drv_5 is << signal .resolved_test_tran_str.dut.gen_chain(3).tc.b.driver : logic3ds >>;
    alias oth_5 is << signal .resolved_test_tran_str.dut.gen_chain(3).tc.b.other : logic3ds >>;
    -- ac(4): gen_chain(4).tc.a
    alias drv_6 is << signal .resolved_test_tran_str.dut.gen_chain(4).tc.a.driver : logic3ds >>;
    alias oth_6 is << signal .resolved_test_tran_str.dut.gen_chain(4).tc.a.other : logic3ds >>;
    -- ac(5): gen_chain(4).tc.b
    alias drv_7 is << signal .resolved_test_tran_str.dut.gen_chain(4).tc.b.driver : logic3ds >>;
    alias oth_7 is << signal .resolved_test_tran_str.dut.gen_chain(4).tc.b.other : logic3ds >>;
    -- ac(5): gen_chain(5).tc.a
    alias drv_8 is << signal .resolved_test_tran_str.dut.gen_chain(5).tc.a.driver : logic3ds >>;
    alias oth_8 is << signal .resolved_test_tran_str.dut.gen_chain(5).tc.a.other : logic3ds >>;
    -- ac(6): gen_chain(5).tc.b
    alias drv_9 is << signal .resolved_test_tran_str.dut.gen_chain(5).tc.b.driver : logic3ds >>;
    alias oth_9 is << signal .resolved_test_tran_str.dut.gen_chain(5).tc.b.other : logic3ds >>;
    -- ac(6): gen_chain(6).tc.a
    alias drv_10 is << signal .resolved_test_tran_str.dut.gen_chain(6).tc.a.driver : logic3ds >>;
    alias oth_10 is << signal .resolved_test_tran_str.dut.gen_chain(6).tc.a.other : logic3ds >>;
    -- ac(7): gen_chain(6).tc.b
    alias drv_11 is << signal .resolved_test_tran_str.dut.gen_chain(6).tc.b.driver : logic3ds >>;
    alias oth_11 is << signal .resolved_test_tran_str.dut.gen_chain(6).tc.b.other : logic3ds >>;
    -- ag(1): gen_row(1).gen_col(1).t_grid.a
    alias drv_12 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(1).t_grid.a.driver : logic3ds >>;
    alias oth_12 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(1).t_grid.a.other : logic3ds >>;
    -- bg(1): gen_row(1).gen_col(1).t_grid.b
    alias drv_13 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(1).t_grid.b.driver : logic3ds >>;
    alias oth_13 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(1).t_grid.b.other : logic3ds >>;
    -- ag(2): gen_row(1).gen_col(2).t_grid.a
    alias drv_14 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(2).t_grid.a.driver : logic3ds >>;
    alias oth_14 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(2).t_grid.a.other : logic3ds >>;
    -- bg(2): gen_row(1).gen_col(2).t_grid.b
    alias drv_15 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(2).t_grid.b.driver : logic3ds >>;
    alias oth_15 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(2).t_grid.b.other : logic3ds >>;
    -- ag(3): gen_row(1).gen_col(3).t_grid.a
    alias drv_16 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(3).t_grid.a.driver : logic3ds >>;
    alias oth_16 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(3).t_grid.a.other : logic3ds >>;
    -- bg(3): gen_row(1).gen_col(3).t_grid.b
    alias drv_17 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(3).t_grid.b.driver : logic3ds >>;
    alias oth_17 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(3).t_grid.b.other : logic3ds >>;
    -- ag(4): gen_row(1).gen_col(4).t_grid.a
    alias drv_18 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(4).t_grid.a.driver : logic3ds >>;
    alias oth_18 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(4).t_grid.a.other : logic3ds >>;
    -- bg(4): gen_row(1).gen_col(4).t_grid.b
    alias drv_19 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(4).t_grid.b.driver : logic3ds >>;
    alias oth_19 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(4).t_grid.b.other : logic3ds >>;
    -- ag(5): gen_row(1).gen_col(5).t_grid.a
    alias drv_20 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(5).t_grid.a.driver : logic3ds >>;
    alias oth_20 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(5).t_grid.a.other : logic3ds >>;
    -- bg(5): gen_row(1).gen_col(5).t_grid.b
    alias drv_21 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(5).t_grid.b.driver : logic3ds >>;
    alias oth_21 is << signal .resolved_test_tran_str.dut.gen_row(1).gen_col(5).t_grid.b.other : logic3ds >>;
    -- ag(6): gen_row(2).gen_col(1).t_grid.a
    alias drv_22 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(1).t_grid.a.driver : logic3ds >>;
    alias oth_22 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(1).t_grid.a.other : logic3ds >>;
    -- bg(6): gen_row(2).gen_col(1).t_grid.b
    alias drv_23 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(1).t_grid.b.driver : logic3ds >>;
    alias oth_23 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(1).t_grid.b.other : logic3ds >>;
    -- ag(7): gen_row(2).gen_col(2).t_grid.a
    alias drv_24 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(2).t_grid.a.driver : logic3ds >>;
    alias oth_24 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(2).t_grid.a.other : logic3ds >>;
    -- bg(7): gen_row(2).gen_col(2).t_grid.b
    alias drv_25 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(2).t_grid.b.driver : logic3ds >>;
    alias oth_25 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(2).t_grid.b.other : logic3ds >>;
    -- ag(8): gen_row(2).gen_col(3).t_grid.a
    alias drv_26 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(3).t_grid.a.driver : logic3ds >>;
    alias oth_26 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(3).t_grid.a.other : logic3ds >>;
    -- bg(8): gen_row(2).gen_col(3).t_grid.b
    alias drv_27 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(3).t_grid.b.driver : logic3ds >>;
    alias oth_27 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(3).t_grid.b.other : logic3ds >>;
    -- ag(9): gen_row(2).gen_col(4).t_grid.a
    alias drv_28 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(4).t_grid.a.driver : logic3ds >>;
    alias oth_28 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(4).t_grid.a.other : logic3ds >>;
    -- bg(9): gen_row(2).gen_col(4).t_grid.b
    alias drv_29 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(4).t_grid.b.driver : logic3ds >>;
    alias oth_29 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(4).t_grid.b.other : logic3ds >>;
    -- ag(10): gen_row(2).gen_col(5).t_grid.a
    alias drv_30 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(5).t_grid.a.driver : logic3ds >>;
    alias oth_30 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(5).t_grid.a.other : logic3ds >>;
    -- bg(10): gen_row(2).gen_col(5).t_grid.b
    alias drv_31 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(5).t_grid.b.driver : logic3ds >>;
    alias oth_31 is << signal .resolved_test_tran_str.dut.gen_row(2).gen_col(5).t_grid.b.other : logic3ds >>;
    -- ag(11): gen_row(3).gen_col(1).t_grid.a
    alias drv_32 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(1).t_grid.a.driver : logic3ds >>;
    alias oth_32 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(1).t_grid.a.other : logic3ds >>;
    -- bg(11): gen_row(3).gen_col(1).t_grid.b
    alias drv_33 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(1).t_grid.b.driver : logic3ds >>;
    alias oth_33 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(1).t_grid.b.other : logic3ds >>;
    -- ag(12): gen_row(3).gen_col(2).t_grid.a
    alias drv_34 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(2).t_grid.a.driver : logic3ds >>;
    alias oth_34 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(2).t_grid.a.other : logic3ds >>;
    -- bg(12): gen_row(3).gen_col(2).t_grid.b
    alias drv_35 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(2).t_grid.b.driver : logic3ds >>;
    alias oth_35 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(2).t_grid.b.other : logic3ds >>;
    -- ag(13): gen_row(3).gen_col(3).t_grid.a
    alias drv_36 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(3).t_grid.a.driver : logic3ds >>;
    alias oth_36 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(3).t_grid.a.other : logic3ds >>;
    -- bg(13): gen_row(3).gen_col(3).t_grid.b
    alias drv_37 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(3).t_grid.b.driver : logic3ds >>;
    alias oth_37 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(3).t_grid.b.other : logic3ds >>;
    -- ag(14): gen_row(3).gen_col(4).t_grid.a
    alias drv_38 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(4).t_grid.a.driver : logic3ds >>;
    alias oth_38 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(4).t_grid.a.other : logic3ds >>;
    -- bg(14): gen_row(3).gen_col(4).t_grid.b
    alias drv_39 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(4).t_grid.b.driver : logic3ds >>;
    alias oth_39 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(4).t_grid.b.other : logic3ds >>;
    -- ag(15): gen_row(3).gen_col(5).t_grid.a
    alias drv_40 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(5).t_grid.a.driver : logic3ds >>;
    alias oth_40 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(5).t_grid.a.other : logic3ds >>;
    -- bg(15): gen_row(3).gen_col(5).t_grid.b
    alias drv_41 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(5).t_grid.b.driver : logic3ds >>;
    alias oth_41 is << signal .resolved_test_tran_str.dut.gen_row(3).gen_col(5).t_grid.b.other : logic3ds >>;
    -- ag(16): gen_row(4).gen_col(1).t_grid.a
    alias drv_42 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(1).t_grid.a.driver : logic3ds >>;
    alias oth_42 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(1).t_grid.a.other : logic3ds >>;
    -- bg(16): gen_row(4).gen_col(1).t_grid.b
    alias drv_43 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(1).t_grid.b.driver : logic3ds >>;
    alias oth_43 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(1).t_grid.b.other : logic3ds >>;
    -- ag(17): gen_row(4).gen_col(2).t_grid.a
    alias drv_44 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(2).t_grid.a.driver : logic3ds >>;
    alias oth_44 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(2).t_grid.a.other : logic3ds >>;
    -- bg(17): gen_row(4).gen_col(2).t_grid.b
    alias drv_45 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(2).t_grid.b.driver : logic3ds >>;
    alias oth_45 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(2).t_grid.b.other : logic3ds >>;
    -- ag(18): gen_row(4).gen_col(3).t_grid.a
    alias drv_46 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(3).t_grid.a.driver : logic3ds >>;
    alias oth_46 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(3).t_grid.a.other : logic3ds >>;
    -- bg(18): gen_row(4).gen_col(3).t_grid.b
    alias drv_47 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(3).t_grid.b.driver : logic3ds >>;
    alias oth_47 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(3).t_grid.b.other : logic3ds >>;
    -- ag(19): gen_row(4).gen_col(4).t_grid.a
    alias drv_48 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(4).t_grid.a.driver : logic3ds >>;
    alias oth_48 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(4).t_grid.a.other : logic3ds >>;
    -- bg(19): gen_row(4).gen_col(4).t_grid.b
    alias drv_49 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(4).t_grid.b.driver : logic3ds >>;
    alias oth_49 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(4).t_grid.b.other : logic3ds >>;
    -- ag(20): gen_row(4).gen_col(5).t_grid.a
    alias drv_50 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(5).t_grid.a.driver : logic3ds >>;
    alias oth_50 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(5).t_grid.a.other : logic3ds >>;
    -- bg(20): gen_row(4).gen_col(5).t_grid.b
    alias drv_51 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(5).t_grid.b.driver : logic3ds >>;
    alias oth_51 is << signal .resolved_test_tran_str.dut.gen_row(4).gen_col(5).t_grid.b.other : logic3ds >>;
    -- ag(21): gen_row(5).gen_col(1).t_grid.a
    alias drv_52 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(1).t_grid.a.driver : logic3ds >>;
    alias oth_52 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(1).t_grid.a.other : logic3ds >>;
    -- bg(21): gen_row(5).gen_col(1).t_grid.b
    alias drv_53 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(1).t_grid.b.driver : logic3ds >>;
    alias oth_53 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(1).t_grid.b.other : logic3ds >>;
    -- ag(22): gen_row(5).gen_col(2).t_grid.a
    alias drv_54 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(2).t_grid.a.driver : logic3ds >>;
    alias oth_54 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(2).t_grid.a.other : logic3ds >>;
    -- bg(22): gen_row(5).gen_col(2).t_grid.b
    alias drv_55 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(2).t_grid.b.driver : logic3ds >>;
    alias oth_55 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(2).t_grid.b.other : logic3ds >>;
    -- ag(23): gen_row(5).gen_col(3).t_grid.a
    alias drv_56 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(3).t_grid.a.driver : logic3ds >>;
    alias oth_56 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(3).t_grid.a.other : logic3ds >>;
    -- bg(23): gen_row(5).gen_col(3).t_grid.b
    alias drv_57 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(3).t_grid.b.driver : logic3ds >>;
    alias oth_57 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(3).t_grid.b.other : logic3ds >>;
    -- ag(24): gen_row(5).gen_col(4).t_grid.a
    alias drv_58 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(4).t_grid.a.driver : logic3ds >>;
    alias oth_58 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(4).t_grid.a.other : logic3ds >>;
    -- bg(24): gen_row(5).gen_col(4).t_grid.b
    alias drv_59 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(4).t_grid.b.driver : logic3ds >>;
    alias oth_59 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(4).t_grid.b.other : logic3ds >>;
    -- ag(25): gen_row(5).gen_col(5).t_grid.a
    alias drv_60 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(5).t_grid.a.driver : logic3ds >>;
    alias oth_60 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(5).t_grid.a.other : logic3ds >>;
    -- bg(25): gen_row(5).gen_col(5).t_grid.b
    alias drv_61 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(5).t_grid.b.driver : logic3ds >>;
    alias oth_61 is << signal .resolved_test_tran_str.dut.gen_row(5).gen_col(5).t_grid.b.other : logic3ds >>;

    -- Receiver signals for tran-only nets
    -- Deposit resolved value here for testbench observability
    alias rcv_ac is << signal .resolved_test_tran_str.dut.ac.receiver : std_logic_vector(1 to 7) >>;
    alias rcv_ag is << signal .resolved_test_tran_str.dut.ag.receiver : std_logic_vector(1 to 25) >>;
    alias rcv_bg is << signal .resolved_test_tran_str.dut.bg.receiver : std_logic_vector(1 to 25) >>;

    -- Convert std_logic to logic3ds with asymmetric strengths
    -- Models Verilog: assign (str1, str0) y = d;
    function to_logic3ds_asym(
        val : std_logic; str1, str0 : l3ds_strength
    ) return logic3ds is
    begin
        case val is
            when '1' | 'H' => return l3ds_drive(true, str1);
            when '0' | 'L' => return l3ds_drive(false, str0);
            when 'Z'       => return L3DS_Z;
            when others     =>
                -- IEEE 1364: if one side is highz (no drive),
                -- the other side wins even with X input.
                -- Both sides non-highz: stays X at max strength.
                if str1 = ST_HIGHZ and str0 = ST_HIGHZ then
                    return L3DS_Z;
                elsif str1 = ST_HIGHZ then
                    return l3ds_drive(false, str0);
                elsif str0 = ST_HIGHZ then
                    return l3ds_drive(true, str1);
                elsif str_gt(str1, str0) then
                    return make_logic3ds(0, str1, FL_UNKNOWN);
                else
                    return make_logic3ds(0, str0, FL_UNKNOWN);
                end if;
        end case;
    end function;

begin

    ---------------------------------------------------------------
    -- Leaf nets: single tran endpoint, no other drivers
    -- Set 'other to L3DS_Z (undriven)
    ---------------------------------------------------------------
    p_leaf: process
    begin
        -- ac(7): gen_chain(6).tc.b
        oth_11 := L3DS_Z;
        -- ag(25): gen_row(5).gen_col(5).t_grid.a
        oth_60 := L3DS_Z;
        -- bg(25): gen_row(5).gen_col(5).t_grid.b
        oth_61 := L3DS_Z;
        wait;
    end process;

    ---------------------------------------------------------------
    -- tran <-> tran (N=2): swap 'driver/'other via deposit
    ---------------------------------------------------------------
    p_swap: process(drv_1, drv_2, drv_3, drv_4, drv_5, drv_6, drv_7, drv_8, drv_9, drv_10)
    begin
        -- ac(2): gen_chain(1).tc.b <-> gen_chain(2).tc.a
        oth_1 := drv_2;
        oth_2 := drv_1;
        -- ac(3): gen_chain(2).tc.b <-> gen_chain(3).tc.a
        oth_3 := drv_4;
        oth_4 := drv_3;
        -- ac(4): gen_chain(3).tc.b <-> gen_chain(4).tc.a
        oth_5 := drv_6;
        oth_6 := drv_5;
        -- ac(5): gen_chain(4).tc.b <-> gen_chain(5).tc.a
        oth_7 := drv_8;
        oth_8 := drv_7;
        -- ac(6): gen_chain(5).tc.b <-> gen_chain(6).tc.a
        oth_9 := drv_10;
        oth_10 := drv_9;
    end process;

    ---------------------------------------------------------------
    -- assign + tran: deposit source value to tran 'other
    ---------------------------------------------------------------
    p_assign_2: process(src_a)
    begin
        -- ac(1): assign(a) (supply1, supply0) -> gen_chain(1).tc.a
        oth_0 := to_logic3ds_asym(src_a, ST_SUPPLY, ST_SUPPLY);
        -- ag(1): assign(a) (supply1, supply0) -> gen_row(1).gen_col(1).t_grid.a
        oth_12 := to_logic3ds_asym(src_a, ST_SUPPLY, ST_SUPPLY);
        -- ag(2): assign(a) (supply1, strong0) -> gen_row(1).gen_col(2).t_grid.a
        oth_14 := to_logic3ds_asym(src_a, ST_SUPPLY, ST_STRONG);
        -- ag(3): assign(a) (supply1, pull0) -> gen_row(1).gen_col(3).t_grid.a
        oth_16 := to_logic3ds_asym(src_a, ST_SUPPLY, ST_PULL);
        -- ag(4): assign(a) (supply1, weak0) -> gen_row(1).gen_col(4).t_grid.a
        oth_18 := to_logic3ds_asym(src_a, ST_SUPPLY, ST_WEAK);
        -- ag(5): assign(a) (supply1, highz0) -> gen_row(1).gen_col(5).t_grid.a
        oth_20 := to_logic3ds_asym(src_a, ST_SUPPLY, ST_HIGHZ);
        -- ag(6): assign(a) (strong1, supply0) -> gen_row(2).gen_col(1).t_grid.a
        oth_22 := to_logic3ds_asym(src_a, ST_STRONG, ST_SUPPLY);
        -- ag(7): assign(a) (strong1, strong0) -> gen_row(2).gen_col(2).t_grid.a
        oth_24 := to_logic3ds_asym(src_a, ST_STRONG, ST_STRONG);
        -- ag(8): assign(a) (strong1, pull0) -> gen_row(2).gen_col(3).t_grid.a
        oth_26 := to_logic3ds_asym(src_a, ST_STRONG, ST_PULL);
        -- ag(9): assign(a) (strong1, weak0) -> gen_row(2).gen_col(4).t_grid.a
        oth_28 := to_logic3ds_asym(src_a, ST_STRONG, ST_WEAK);
        -- ag(10): assign(a) (strong1, highz0) -> gen_row(2).gen_col(5).t_grid.a
        oth_30 := to_logic3ds_asym(src_a, ST_STRONG, ST_HIGHZ);
        -- ag(11): assign(a) (pull1, supply0) -> gen_row(3).gen_col(1).t_grid.a
        oth_32 := to_logic3ds_asym(src_a, ST_PULL, ST_SUPPLY);
        -- ag(12): assign(a) (pull1, strong0) -> gen_row(3).gen_col(2).t_grid.a
        oth_34 := to_logic3ds_asym(src_a, ST_PULL, ST_STRONG);
        -- ag(13): assign(a) (pull1, pull0) -> gen_row(3).gen_col(3).t_grid.a
        oth_36 := to_logic3ds_asym(src_a, ST_PULL, ST_PULL);
        -- ag(14): assign(a) (pull1, weak0) -> gen_row(3).gen_col(4).t_grid.a
        oth_38 := to_logic3ds_asym(src_a, ST_PULL, ST_WEAK);
        -- ag(15): assign(a) (pull1, highz0) -> gen_row(3).gen_col(5).t_grid.a
        oth_40 := to_logic3ds_asym(src_a, ST_PULL, ST_HIGHZ);
        -- ag(16): assign(a) (weak1, supply0) -> gen_row(4).gen_col(1).t_grid.a
        oth_42 := to_logic3ds_asym(src_a, ST_WEAK, ST_SUPPLY);
        -- ag(17): assign(a) (weak1, strong0) -> gen_row(4).gen_col(2).t_grid.a
        oth_44 := to_logic3ds_asym(src_a, ST_WEAK, ST_STRONG);
        -- ag(18): assign(a) (weak1, pull0) -> gen_row(4).gen_col(3).t_grid.a
        oth_46 := to_logic3ds_asym(src_a, ST_WEAK, ST_PULL);
        -- ag(19): assign(a) (weak1, weak0) -> gen_row(4).gen_col(4).t_grid.a
        oth_48 := to_logic3ds_asym(src_a, ST_WEAK, ST_WEAK);
        -- ag(20): assign(a) (weak1, highz0) -> gen_row(4).gen_col(5).t_grid.a
        oth_50 := to_logic3ds_asym(src_a, ST_WEAK, ST_HIGHZ);
        -- ag(21): assign(a) (highz1, supply0) -> gen_row(5).gen_col(1).t_grid.a
        oth_52 := to_logic3ds_asym(src_a, ST_HIGHZ, ST_SUPPLY);
        -- ag(22): assign(a) (highz1, strong0) -> gen_row(5).gen_col(2).t_grid.a
        oth_54 := to_logic3ds_asym(src_a, ST_HIGHZ, ST_STRONG);
        -- ag(23): assign(a) (highz1, pull0) -> gen_row(5).gen_col(3).t_grid.a
        oth_56 := to_logic3ds_asym(src_a, ST_HIGHZ, ST_PULL);
        -- ag(24): assign(a) (highz1, weak0) -> gen_row(5).gen_col(4).t_grid.a
        oth_58 := to_logic3ds_asym(src_a, ST_HIGHZ, ST_WEAK);
    end process;

    p_assign_3: process(src_b)
    begin
        -- bg(1): assign(b) (supply1, supply0) -> gen_row(1).gen_col(1).t_grid.b
        oth_13 := to_logic3ds_asym(src_b, ST_SUPPLY, ST_SUPPLY);
        -- bg(2): assign(b) (supply1, strong0) -> gen_row(1).gen_col(2).t_grid.b
        oth_15 := to_logic3ds_asym(src_b, ST_SUPPLY, ST_STRONG);
        -- bg(3): assign(b) (supply1, pull0) -> gen_row(1).gen_col(3).t_grid.b
        oth_17 := to_logic3ds_asym(src_b, ST_SUPPLY, ST_PULL);
        -- bg(4): assign(b) (supply1, weak0) -> gen_row(1).gen_col(4).t_grid.b
        oth_19 := to_logic3ds_asym(src_b, ST_SUPPLY, ST_WEAK);
        -- bg(5): assign(b) (supply1, highz0) -> gen_row(1).gen_col(5).t_grid.b
        oth_21 := to_logic3ds_asym(src_b, ST_SUPPLY, ST_HIGHZ);
        -- bg(6): assign(b) (strong1, supply0) -> gen_row(2).gen_col(1).t_grid.b
        oth_23 := to_logic3ds_asym(src_b, ST_STRONG, ST_SUPPLY);
        -- bg(7): assign(b) (strong1, strong0) -> gen_row(2).gen_col(2).t_grid.b
        oth_25 := to_logic3ds_asym(src_b, ST_STRONG, ST_STRONG);
        -- bg(8): assign(b) (strong1, pull0) -> gen_row(2).gen_col(3).t_grid.b
        oth_27 := to_logic3ds_asym(src_b, ST_STRONG, ST_PULL);
        -- bg(9): assign(b) (strong1, weak0) -> gen_row(2).gen_col(4).t_grid.b
        oth_29 := to_logic3ds_asym(src_b, ST_STRONG, ST_WEAK);
        -- bg(10): assign(b) (strong1, highz0) -> gen_row(2).gen_col(5).t_grid.b
        oth_31 := to_logic3ds_asym(src_b, ST_STRONG, ST_HIGHZ);
        -- bg(11): assign(b) (pull1, supply0) -> gen_row(3).gen_col(1).t_grid.b
        oth_33 := to_logic3ds_asym(src_b, ST_PULL, ST_SUPPLY);
        -- bg(12): assign(b) (pull1, strong0) -> gen_row(3).gen_col(2).t_grid.b
        oth_35 := to_logic3ds_asym(src_b, ST_PULL, ST_STRONG);
        -- bg(13): assign(b) (pull1, pull0) -> gen_row(3).gen_col(3).t_grid.b
        oth_37 := to_logic3ds_asym(src_b, ST_PULL, ST_PULL);
        -- bg(14): assign(b) (pull1, weak0) -> gen_row(3).gen_col(4).t_grid.b
        oth_39 := to_logic3ds_asym(src_b, ST_PULL, ST_WEAK);
        -- bg(15): assign(b) (pull1, highz0) -> gen_row(3).gen_col(5).t_grid.b
        oth_41 := to_logic3ds_asym(src_b, ST_PULL, ST_HIGHZ);
        -- bg(16): assign(b) (weak1, supply0) -> gen_row(4).gen_col(1).t_grid.b
        oth_43 := to_logic3ds_asym(src_b, ST_WEAK, ST_SUPPLY);
        -- bg(17): assign(b) (weak1, strong0) -> gen_row(4).gen_col(2).t_grid.b
        oth_45 := to_logic3ds_asym(src_b, ST_WEAK, ST_STRONG);
        -- bg(18): assign(b) (weak1, pull0) -> gen_row(4).gen_col(3).t_grid.b
        oth_47 := to_logic3ds_asym(src_b, ST_WEAK, ST_PULL);
        -- bg(19): assign(b) (weak1, weak0) -> gen_row(4).gen_col(4).t_grid.b
        oth_49 := to_logic3ds_asym(src_b, ST_WEAK, ST_WEAK);
        -- bg(20): assign(b) (weak1, highz0) -> gen_row(4).gen_col(5).t_grid.b
        oth_51 := to_logic3ds_asym(src_b, ST_WEAK, ST_HIGHZ);
        -- bg(21): assign(b) (highz1, supply0) -> gen_row(5).gen_col(1).t_grid.b
        oth_53 := to_logic3ds_asym(src_b, ST_HIGHZ, ST_SUPPLY);
        -- bg(22): assign(b) (highz1, strong0) -> gen_row(5).gen_col(2).t_grid.b
        oth_55 := to_logic3ds_asym(src_b, ST_HIGHZ, ST_STRONG);
        -- bg(23): assign(b) (highz1, pull0) -> gen_row(5).gen_col(3).t_grid.b
        oth_57 := to_logic3ds_asym(src_b, ST_HIGHZ, ST_PULL);
        -- bg(24): assign(b) (highz1, weak0) -> gen_row(5).gen_col(4).t_grid.b
        oth_59 := to_logic3ds_asym(src_b, ST_HIGHZ, ST_WEAK);
    end process;

    ---------------------------------------------------------------
    -- Resolve ALL drivers (assign + tran) and deposit to receiver
    -- No concurrent assignments in DUT; this is the sole source
    -- of signal values, preserving strength semantics.
    ---------------------------------------------------------------
    p_receivers: process(drv_0, drv_1, drv_2, drv_3, drv_4, drv_5, drv_6, drv_7, drv_8, drv_9, drv_10, drv_11, drv_12, drv_13, drv_14, drv_15, drv_16, drv_17, drv_18, drv_19, drv_20, drv_21, drv_22, drv_23, drv_24, drv_25, drv_26, drv_27, drv_28, drv_29, drv_30, drv_31, drv_32, drv_33, drv_34, drv_35, drv_36, drv_37, drv_38, drv_39, drv_40, drv_41, drv_42, drv_43, drv_44, drv_45, drv_46, drv_47, drv_48, drv_49, drv_50, drv_51, drv_52, drv_53, drv_54, drv_55, drv_56, drv_57, drv_58, drv_59, drv_60, drv_61, src_a, src_b)
        variable v_ac : std_logic_vector(1 to 7) := (others => 'U');
        variable v_ag : std_logic_vector(1 to 25) := (others => 'U');
        variable v_bg : std_logic_vector(1 to 25) := (others => 'U');
    begin
        -- ac: compute all elements
        v_ac(1) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_SUPPLY, ST_SUPPLY), drv_0)));
        v_ac(2) := to_std_logic(l3ds_resolve(logic3ds_vector'(drv_1, drv_2)));
        v_ac(3) := to_std_logic(l3ds_resolve(logic3ds_vector'(drv_3, drv_4)));
        v_ac(4) := to_std_logic(l3ds_resolve(logic3ds_vector'(drv_5, drv_6)));
        v_ac(5) := to_std_logic(l3ds_resolve(logic3ds_vector'(drv_7, drv_8)));
        v_ac(6) := to_std_logic(l3ds_resolve(logic3ds_vector'(drv_9, drv_10)));
        v_ac(7) := to_std_logic(drv_11);
        rcv_ac := v_ac;

        -- ag: compute all elements
        v_ag(1) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_SUPPLY, ST_SUPPLY), drv_12)));
        v_ag(2) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_SUPPLY, ST_STRONG), drv_14)));
        v_ag(3) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_SUPPLY, ST_PULL), drv_16)));
        v_ag(4) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_SUPPLY, ST_WEAK), drv_18)));
        v_ag(5) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_SUPPLY, ST_HIGHZ), drv_20)));
        v_ag(6) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_STRONG, ST_SUPPLY), drv_22)));
        v_ag(7) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_STRONG, ST_STRONG), drv_24)));
        v_ag(8) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_STRONG, ST_PULL), drv_26)));
        v_ag(9) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_STRONG, ST_WEAK), drv_28)));
        v_ag(10) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_STRONG, ST_HIGHZ), drv_30)));
        v_ag(11) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_PULL, ST_SUPPLY), drv_32)));
        v_ag(12) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_PULL, ST_STRONG), drv_34)));
        v_ag(13) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_PULL, ST_PULL), drv_36)));
        v_ag(14) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_PULL, ST_WEAK), drv_38)));
        v_ag(15) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_PULL, ST_HIGHZ), drv_40)));
        v_ag(16) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_WEAK, ST_SUPPLY), drv_42)));
        v_ag(17) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_WEAK, ST_STRONG), drv_44)));
        v_ag(18) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_WEAK, ST_PULL), drv_46)));
        v_ag(19) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_WEAK, ST_WEAK), drv_48)));
        v_ag(20) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_WEAK, ST_HIGHZ), drv_50)));
        v_ag(21) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_HIGHZ, ST_SUPPLY), drv_52)));
        v_ag(22) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_HIGHZ, ST_STRONG), drv_54)));
        v_ag(23) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_HIGHZ, ST_PULL), drv_56)));
        v_ag(24) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_a, ST_HIGHZ, ST_WEAK), drv_58)));
        v_ag(25) := to_std_logic(drv_60);
        rcv_ag := v_ag;

        -- bg: compute all elements
        v_bg(1) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_SUPPLY, ST_SUPPLY), drv_13)));
        v_bg(2) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_SUPPLY, ST_STRONG), drv_15)));
        v_bg(3) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_SUPPLY, ST_PULL), drv_17)));
        v_bg(4) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_SUPPLY, ST_WEAK), drv_19)));
        v_bg(5) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_SUPPLY, ST_HIGHZ), drv_21)));
        v_bg(6) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_STRONG, ST_SUPPLY), drv_23)));
        v_bg(7) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_STRONG, ST_STRONG), drv_25)));
        v_bg(8) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_STRONG, ST_PULL), drv_27)));
        v_bg(9) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_STRONG, ST_WEAK), drv_29)));
        v_bg(10) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_STRONG, ST_HIGHZ), drv_31)));
        v_bg(11) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_PULL, ST_SUPPLY), drv_33)));
        v_bg(12) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_PULL, ST_STRONG), drv_35)));
        v_bg(13) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_PULL, ST_PULL), drv_37)));
        v_bg(14) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_PULL, ST_WEAK), drv_39)));
        v_bg(15) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_PULL, ST_HIGHZ), drv_41)));
        v_bg(16) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_WEAK, ST_SUPPLY), drv_43)));
        v_bg(17) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_WEAK, ST_STRONG), drv_45)));
        v_bg(18) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_WEAK, ST_PULL), drv_47)));
        v_bg(19) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_WEAK, ST_WEAK), drv_49)));
        v_bg(20) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_WEAK, ST_HIGHZ), drv_51)));
        v_bg(21) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_HIGHZ, ST_SUPPLY), drv_53)));
        v_bg(22) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_HIGHZ, ST_STRONG), drv_55)));
        v_bg(23) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_HIGHZ, ST_PULL), drv_57)));
        v_bg(24) := to_std_logic(l3ds_resolve(logic3ds_vector'(to_logic3ds_asym(src_b, ST_HIGHZ, ST_WEAK), drv_59)));
        v_bg(25) := to_std_logic(drv_61);
        rcv_bg := v_bg;

    end process;

end architecture;

-- Wrapper: instantiates DUT + resolver for standalone simulation
library ieee;
use ieee.std_logic_1164.all;

entity resolved_test_tran_str is end;
architecture wrapper of resolved_test_tran_str is
begin
    dut: entity work.test_tran_str;
    resolver: entity work.resolver_test_tran_str;
end architecture;
