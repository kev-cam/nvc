"""
sv2vhdl_resolver.py -- Resolution network VHDL generator for sv2vhdl

Called by libresolver.so (VHPI plugin) when the simulator discovers
nets that need resolution (tran entities with multiple inout ports).

Each net dict has:
    net_name   : str  -- tran instance ename path
    drivers    : list -- [{ename: str, type: str}, ...]
    receivers  : list -- [{ename: str, type: str}, ...]

For a 2-endpoint net (the common tran case), resolution is a simple swap:
    receiver[0] <= driver[1]
    receiver[1] <= driver[0]

For N>2 endpoints, each receiver gets the resolution of all other drivers.

Returns a dict mapping filenames to VHDL strings:
    - One file per net: "{design}_rn_{i}.vhd" with its own entity
    - One wrapper file: "{design}_wrapper.vhd" instantiating DUT + all resolvers

This per-net structure allows incremental recompilation when only some
nets change.

The _sv2vhdl_vhpi module (registered by the C plugin) provides direct
VHPI access for Python-driven hierarchy exploration:
    _sv2vhdl_vhpi.get_signals(region_path)   -> [signal dicts]
    _sv2vhdl_vhpi.get_instances(region_path) -> [instance dicts]
    _sv2vhdl_vhpi.get_generics(path)         -> {name: value}
    _sv2vhdl_vhpi.get_value(signal_path)     -> string value
    _sv2vhdl_vhpi.get_signal_info(path)      -> signal dict with value
"""

# Import VHPI bridge â€” available when running inside the simulator plugin
try:
    import _sv2vhdl_vhpi as vhpi
    _have_vhpi = True
except ImportError:
    _have_vhpi = False


def _djb2(s, h=5381):
    """DJB2 hash matching the C implementation."""
    for c in s.encode():
        h = (h * 33 + c) & 0xFFFFFFFFFFFFFFFF
    return h


def _net_hash(net):
    """Hash a single net's topology and types for per-file caching."""
    h = 5381
    h = _djb2(net["net_name"], h)
    for drv in net["drivers"]:
        h = _djb2(drv["ename"], h)
        h = _djb2(drv.get("type", ""), h)
    for rcv in net["receivers"]:
        h = _djb2(rcv["ename"], h)
        h = _djb2(rcv.get("type", ""), h)
    return h


def _sanitize_id(name):
    """Turn a hierarchical path into a valid VHDL identifier for labels."""
    return name.replace(".", "_").replace(":", "_").replace("@", "").replace(
        "(", "_").replace(")", "_").strip("_")


def _type_info(net):
    """Determine resolution function, vector type, and use clauses for a net.

    Inspects the first tran (non-signal) driver's type to choose the
    appropriate resolution infrastructure:
      - logic3ds  -> l3ds_resolve / logic3ds_vector  (logic3ds_pkg)
      - logic3d   -> l3d_resolve  / logic3d_vector   (logic3d_types_pkg)
      - std_logic -> resolved     / std_ulogic_vector (std_logic_1164)

    Returns (resolve_func, vec_type, extra_use_clauses).
    """
    if not net["drivers"]:
        return "resolved", "std_ulogic_vector", []

    # Use the first non-signal endpoint's type for resolution
    ep_type = "std_logic"
    for drv in net["drivers"]:
        if not drv.get("is_signal"):
            ep_type = drv["type"].lower()
            break

    if ep_type == "logic3ds":
        return ("l3ds_resolve", "logic3ds_vector",
                ["use work.logic3ds_pkg.all;"])
    elif ep_type == "logic3d":
        return ("l3d_resolve", "logic3d_vector",
                ["use work.logic3d_types_pkg.all;"])
    else:
        return ("resolved", "std_ulogic_vector", [])


def _gen_net_vhdl(net, idx, design_name, fix_ename):
    """Generate VHDL for a single net's resolver entity.

    Each resolver entity:
      - Reads 'DRIVER signals from tran endpoints on this net
      - Reads net signals from signal endpoints (read-only, no receiver)
      - Computes per-tran-endpoint 'OTHER (exclude self, include signals)
      - Uses type conversion for signal endpoints when needed

    Returns (entity_name, vhdl_string).
    """
    entity_name = f"sv2vhdl_rn_{design_name}_{idx}"
    net_h = _net_hash(net)
    n_ep = len(net["drivers"])

    # Classify endpoints: signal (read-only) vs tran (has receiver)
    sig_indices = set()
    tran_indices = []
    for i, drv in enumerate(net["drivers"]):
        if drv.get("is_signal"):
            sig_indices.add(i)
        else:
            tran_indices.append(i)

    resolve_func, vec_type, extra_uses = _type_info(net)

    # Determine the tran endpoint type (for conversion decisions)
    tran_type = "std_logic"
    for i in tran_indices:
        tran_type = net["drivers"][i]["type"].lower()
        break

    lines = []
    lines.append(f"-- Net hash: {net_h:016x}")
    lines.append(f"-- Net: {net['net_name']} ({n_ep} endpoints)")
    lines.append(f"-- Auto-generated by sv2vhdl resolver plugin")
    lines.append(f"")
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    for use in extra_uses:
        lines.append(use)
    lines.append(f"")
    lines.append(f"entity {entity_name} is end;")
    lines.append(f"architecture generated of {entity_name} is")

    # Alias declarations
    drv_aliases = []  # "drv_X" for tran, "sig_X" for signal endpoints
    rcv_aliases = []  # "rcv_X" for tran, None for signal endpoints
    for i in range(n_ep):
        drv = net["drivers"][i]
        rcv = net["receivers"][i]
        if i in sig_indices:
            da = f"sig_{i}"
            drv_path = fix_ename(drv["ename"])
            drv_type = drv["type"].lower()
            lines.append(f"    alias {da} is "
                         f"<< signal {drv_path} : {drv_type} >>;")
            drv_aliases.append(da)
            rcv_aliases.append(None)
        else:
            da = f"drv_{i}"
            ra = f"rcv_{i}"
            drv_path = fix_ename(drv["ename"])
            rcv_path = fix_ename(rcv["ename"])
            drv_type = drv["type"].lower()
            rcv_type = rcv["type"].lower()
            lines.append(f"    alias {da} is "
                         f"<< signal {drv_path} : {drv_type} >>;")
            lines.append(f"    alias {ra} is "
                         f"<< signal {rcv_path} : {rcv_type} >>;")
            drv_aliases.append(da)
            rcv_aliases.append(ra)

    lines.append(f"begin")

    def _drv_expr(j):
        """VHDL expression for endpoint j's driver value, with type
        conversion to tran_type when the signal endpoint type differs."""
        if j in sig_indices:
            sig_type = net["drivers"][j]["type"].lower()
            if sig_type != tran_type:
                if tran_type == "logic3ds":
                    return f"to_logic3ds({drv_aliases[j]}, ST_SUPPLY)"
                elif tran_type == "logic3d":
                    return f"to_logic3d({drv_aliases[j]})"
        return drv_aliases[j]

    if not tran_indices:
        lines.append(f"    -- no tran endpoints, nothing to resolve")
    else:
        # One process per tran endpoint's 'other signal
        # Signal endpoints are read-only (no receiver, no process)
        for i in tran_indices:
            others = [j for j in range(n_ep) if j != i]
            sens = ", ".join(drv_aliases[j] for j in others)
            lines.append(f"    p_{i}: process({sens})")
            if len(others) > 1:
                lines.append(f"        variable v : {vec_type}"
                             f"(0 to {len(others) - 1});")
            lines.append(f"    begin")
            if len(others) == 1:
                lines.append(f"        {rcv_aliases[i]} := "
                             f"{_drv_expr(others[0])};")
            else:
                for k, j in enumerate(others):
                    lines.append(f"        v({k}) := {_drv_expr(j)};")
                lines.append(f"        {rcv_aliases[i]} := "
                             f"{resolve_func}(v);")
            lines.append(f"    end process;")

    lines.append(f"end architecture;")
    lines.append(f"")

    return entity_name, "\n".join(lines)


def resolve_net(nets, design_name):
    """Generate per-net VHDL resolver entities and a wrapper.

    Args:
        nets: list of net dicts (see module docstring)
        design_name: top-level entity name (lowercase)

    Returns:
        dict: {filename: vhdl_string} with one file per net + wrapper,
              or None if nothing to generate.
    """
    if not nets:
        return None

    wrapper_entity = f"resolved_{design_name}"
    dut_label = "dut"

    orig_prefix = f".{design_name}."
    new_prefix = f".{wrapper_entity}.{dut_label}."

    def fix_ename(ename):
        if ename.startswith(orig_prefix):
            return new_prefix + ename[len(orig_prefix):]
        return ename

    files = {}
    entity_names = []

    # Generate one file per net
    for idx, net in enumerate(nets):
        entity_name, vhdl = _gen_net_vhdl(net, idx, design_name, fix_ename)
        filename = f"{design_name}_rn_{idx}.vhd"
        files[filename] = vhdl
        entity_names.append(entity_name)

    # Generate wrapper file
    lines = []
    lines.append(f"-- Wrapper: instantiates DUT + {len(nets)} resolver(s)")
    lines.append(f"-- Auto-generated by sv2vhdl resolver plugin")
    lines.append(f"")
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    lines.append(f"")
    lines.append(f"entity {wrapper_entity} is end;")
    lines.append(f"architecture wrapper of {wrapper_entity} is")
    lines.append(f"begin")
    lines.append(f"    {dut_label}: entity work.{design_name};")
    for idx, ename in enumerate(entity_names):
        lines.append(f"    rn_{idx}: entity work.{ename};")
    lines.append(f"end architecture;")
    lines.append(f"")

    files[f"{design_name}_wrapper.vhd"] = "\n".join(lines)

    return files


# ---------- VHPI exploration helpers ----------

def explore_region(region_path):
    """Explore a design region using VHPI bridge.

    Returns dict with signals, instances, and any power supplies found.
    """
    if not _have_vhpi:
        raise RuntimeError("VHPI bridge not available (not running in simulator)")

    signals = vhpi.get_signals(region_path)
    instances = vhpi.get_instances(region_path)

    # Identify power supply signals by naming convention
    power_signals = {}
    for sig in signals:
        name = sig["name"].upper()
        if name.endswith("_VDD") or name == "VDD":
            power_signals.setdefault("vdd", []).append(sig)
        elif name.endswith("_VSS") or name == "VSS":
            power_signals.setdefault("vss", []).append(sig)

    return {
        "signals": signals,
        "instances": instances,
        "power": power_signals,
    }


def find_power_supplies(net_ename):
    """Find power supply signals in the same scope as a net."""
    if not _have_vhpi:
        return {}

    parent = net_ename.rsplit(".", 1)[0]
    if not parent:
        return {}

    try:
        signals = vhpi.get_signals(parent)
    except (KeyError, RuntimeError):
        return {}

    power = {}
    for sig in signals:
        name = sig["name"].upper()
        if name.endswith("_VDD") or name == "VDD":
            power.setdefault("vdd", []).append(sig)
        elif name.endswith("_VSS") or name == "VSS":
            power.setdefault("vss", []).append(sig)

    return power


def get_instance_generics(instance_ename):
    """Read generics from an instance via VHPI."""
    if not _have_vhpi:
        return {}

    try:
        return vhpi.get_generics(instance_ename)
    except (KeyError, RuntimeError):
        return {}
