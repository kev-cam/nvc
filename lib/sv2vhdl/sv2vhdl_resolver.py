"""
sv2vhdl_resolver.py -- Resolution network VHDL generator for sv2vhdl

Called by libresolver.so (VHPI plugin) when the simulator discovers
nets that need resolution (vector _driver/_others signal pairs with
length > 1).

Each net dict has:
    net_name     : str  -- base net name (VHPI full path minus suffix)
    type         : str  -- element type (e.g. "STD_LOGIC")
    length       : int  -- number of endpoints (vector size)
    driver_ename : str  -- external name path to _driver signal
    others_ename : str  -- external name path to _others signal

Returns a VHDL string containing:
    1. A resolver entity (no ports, uses external names)
    2. A wrapper entity (instantiates DUT + resolver)

The _sv2vhdl_vhpi module (registered by the C plugin) provides direct
VHPI access for Python-driven hierarchy exploration:
    _sv2vhdl_vhpi.get_signals(region_path)   -> [signal dicts]
    _sv2vhdl_vhpi.get_instances(region_path) -> [instance dicts]
    _sv2vhdl_vhpi.get_generics(path)         -> {name: value}
    _sv2vhdl_vhpi.get_value(signal_path)     -> string value
    _sv2vhdl_vhpi.get_signal_info(path)      -> signal dict with value
"""

# Import VHPI bridge â€” available when running inside the simulator plugin
try:
    import _sv2vhdl_vhpi as vhpi
    _have_vhpi = True
except ImportError:
    _have_vhpi = False


def _djb2(s, h=5381):
    """DJB2 hash matching the C implementation."""
    for c in s.encode():
        h = (h * 33 + c) & 0xFFFFFFFFFFFFFFFF
    return h


def _topology_hash(nets):
    """Compute topology hash over sorted nets (must match C side)."""
    sorted_nets = sorted(nets, key=lambda n: n["net_name"])
    h = 5381
    for n in sorted_nets:
        desc = f'{n["net_name"]}:{n["type"]}:{n["length"]}'
        h = _djb2(desc, h)
    return h


def _sanitize_id(name):
    """Turn a hierarchical path into a valid VHDL identifier for labels."""
    return name.replace(".", "_").replace(":", "_").replace("@", "").strip("_")


def _type_str(sig_type, length):
    """Build the VHDL type string for an external name.

    sig_type is the signal's own type (e.g. STD_LOGIC_VECTOR for arrays,
    STD_LOGIC for scalars). For arrays, append the range constraint.
    """
    t = sig_type.lower()
    if length == 1:
        return t
    return f"{t}(0 to {length - 1})"


def _gen_resolution_process(net, drv_alias, oth_alias):
    """Generate VHDL process for one net's resolution logic."""
    length = net["length"]
    label = f"resolve_{_sanitize_id(net['net_name'])}"
    lines = []

    lines.append(f"    {label}: process({drv_alias})")
    lines.append(f"    begin")

    if length == 2:
        # Simple swap: others(0) = driver(1), others(1) = driver(0)
        lines.append(f"        {oth_alias}(0) <= {drv_alias}(1);")
        lines.append(f"        {oth_alias}(1) <= {drv_alias}(0);")
    else:
        # N>2: others(i) = resolved(all drivers except i)
        for i in range(length):
            parts = [f"{drv_alias}({j})" for j in range(length) if j != i]
            expr = " & ".join(parts)
            lines.append(f"        {oth_alias}({i}) <= resolved({expr});")

    lines.append(f"    end process;")
    return "\n".join(lines)


def resolve_net(nets, design_name):
    """Generate VHDL resolver code for multi-endpoint nets.

    Args:
        nets: list of net dicts (see module docstring)
        design_name: top-level entity name (lowercase)

    Returns:
        str: Complete VHDL source, or None if nothing to generate.
    """
    if not nets:
        return None

    topo_hash = _topology_hash(nets)
    resolver_entity = f"sv2vhdl_resolver_{design_name}"
    wrapper_entity = f"resolved_{design_name}"
    dut_label = "dut"

    # Transform ename paths: replace absolute root with wrapper.dut path
    # Original: .test_resolver_tb.sig  ->  .resolved_test_resolver_tb.dut.sig
    orig_prefix = f".{design_name}."
    new_prefix = f".{wrapper_entity}.{dut_label}."

    def fix_ename(ename):
        if ename.startswith(orig_prefix):
            return new_prefix + ename[len(orig_prefix):]
        return ename

    lines = []

    # Header
    lines.append(f"-- Topology hash: {topo_hash:016x}")
    lines.append(f"-- Auto-generated by sv2vhdl resolver plugin")
    lines.append(f"-- {len(nets)} net(s) requiring resolution")
    lines.append(f"")
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    lines.append(f"")

    # Resolver entity (no ports)
    lines.append(f"entity {resolver_entity} is end;")
    lines.append(f"architecture generated of {resolver_entity} is")

    # Alias declarations for external names (paths adjusted for wrapper)
    for i, net in enumerate(nets):
        drv_alias = f"drv_{i}"
        oth_alias = f"oth_{i}"
        type_s = _type_str(net["type"], net["length"])
        drv_path = fix_ename(net["driver_ename"])
        oth_path = fix_ename(net["others_ename"])
        lines.append(f"    alias {drv_alias} is "
                     f"<< signal {drv_path} : {type_s} >>;")
        lines.append(f"    alias {oth_alias} is "
                     f"<< signal {oth_path} : {type_s} >>;")

    lines.append(f"begin")

    # Resolution processes
    for i, net in enumerate(nets):
        drv_alias = f"drv_{i}"
        oth_alias = f"oth_{i}"
        lines.append(f"")
        lines.append(f"    -- Net: {net['net_name']} "
                     f"({net['length']} endpoints, {net['type']})")
        lines.append(_gen_resolution_process(net, drv_alias, oth_alias))

    lines.append(f"")
    lines.append(f"end architecture;")
    lines.append(f"")

    # Wrapper entity: instantiates DUT + resolver
    lines.append(f"-- Wrapper: run this for standalone simulation")
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    lines.append(f"")
    lines.append(f"entity {wrapper_entity} is end;")
    lines.append(f"architecture wrapper of {wrapper_entity} is")
    lines.append(f"begin")
    lines.append(f"    dut: entity work.{design_name};")
    lines.append(f"    resolver: entity work.{resolver_entity};")
    lines.append(f"end architecture;")
    lines.append(f"")

    # Use VHPI bridge to explore the design scope
    if _have_vhpi and nets:
        parent = nets[0]["driver_ename"].rsplit(".", 1)[0]
        try:
            info = explore_region(parent)
            n_sig = len(info["signals"])
            n_inst = len(info["instances"])
            print(f"[sv2vhdl] VHPI bridge: explored {parent} "
                  f"({n_sig} signals, {n_inst} instances)")

            # Report power supplies
            if info["power"]:
                for rail, sigs in info["power"].items():
                    for s in sigs:
                        print(f"[sv2vhdl]   power {rail}: "
                              f"{s['name']} ({s['ename']})")

            # Report instance generics
            for inst in info["instances"]:
                gens = get_instance_generics(inst["ename"])
                if gens:
                    print(f"[sv2vhdl]   {inst['name']} generics: {gens}")
        except Exception as e:
            print(f"[sv2vhdl] VHPI explore: {e}")

    return "\n".join(lines)


# ---------- VHPI exploration helpers ----------

def explore_region(region_path):
    """Explore a design region using VHPI bridge.

    Returns dict with signals, instances, and any power supplies found.
    """
    if not _have_vhpi:
        raise RuntimeError("VHPI bridge not available (not running in simulator)")

    signals = vhpi.get_signals(region_path)
    instances = vhpi.get_instances(region_path)

    # Identify power supply signals by naming convention
    power_signals = {}
    for sig in signals:
        name = sig["name"].upper()
        if name.endswith("_VDD") or name == "VDD":
            power_signals.setdefault("vdd", []).append(sig)
        elif name.endswith("_VSS") or name == "VSS":
            power_signals.setdefault("vss", []).append(sig)

    return {
        "signals": signals,
        "instances": instances,
        "power": power_signals,
    }


def find_power_supplies(net_ename):
    """Find power supply signals in the same scope as a net.

    Given a signal ename like '.top.net_a_driver', looks in the parent
    region ('.top') for signals matching VDD/VSS naming conventions.

    Returns: dict with 'vdd' and 'vss' lists of signal dicts, or empty
    if no power signals found or VHPI not available.
    """
    if not _have_vhpi:
        return {}

    # Derive parent region from signal ename
    parent = net_ename.rsplit(".", 1)[0]
    if not parent:
        return {}

    try:
        signals = vhpi.get_signals(parent)
    except (KeyError, RuntimeError):
        return {}

    power = {}
    for sig in signals:
        name = sig["name"].upper()
        if name.endswith("_VDD") or name == "VDD":
            power.setdefault("vdd", []).append(sig)
        elif name.endswith("_VSS") or name == "VSS":
            power.setdefault("vss", []).append(sig)

    return power


def get_instance_generics(instance_ename):
    """Read generics from an instance via VHPI.

    Returns dict of {generic_name: value} or empty dict.
    """
    if not _have_vhpi:
        return {}

    try:
        return vhpi.get_generics(instance_ename)
    except (KeyError, RuntimeError):
        return {}
