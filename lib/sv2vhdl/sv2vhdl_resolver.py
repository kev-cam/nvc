"""
sv2vhdl_resolver.py -- Resolution network VHDL generator for sv2vhdl

Called by libresolver.so (VHPI plugin) when the simulator discovers
nets that need resolution (tran entities with multiple inout ports).

Each net dict has:
    net_name   : str  -- tran instance ename path
    drivers    : list -- [{ename: str, type: str}, ...]
    receivers  : list -- [{ename: str, type: str}, ...]

For a 2-endpoint net (the common tran case), resolution is a simple swap:
    receiver[0] <= driver[1]
    receiver[1] <= driver[0]

For N>2 endpoints, each receiver gets the resolution of all other drivers.

Returns a dict mapping filenames to VHDL strings:
    - One file per net: "{design}_rn_{i}.vhd" with its own entity
    - One wrapper file: "{design}_wrapper.vhd" instantiating DUT + all resolvers

This per-net structure allows incremental recompilation when only some
nets change.

The _sv2vhdl_vhpi module (registered by the C plugin) provides direct
VHPI access for Python-driven hierarchy exploration:
    _sv2vhdl_vhpi.get_signals(region_path)   -> [signal dicts]
    _sv2vhdl_vhpi.get_instances(region_path) -> [instance dicts]
    _sv2vhdl_vhpi.get_generics(path)         -> {name: value}
    _sv2vhdl_vhpi.get_value(signal_path)     -> string value
    _sv2vhdl_vhpi.get_signal_info(path)      -> signal dict with value
"""

# Import VHPI bridge â€” available when running inside the simulator plugin
try:
    import _sv2vhdl_vhpi as vhpi
    _have_vhpi = True
except ImportError:
    _have_vhpi = False


def _djb2(s, h=5381):
    """DJB2 hash matching the C implementation."""
    for c in s.encode():
        h = (h * 33 + c) & 0xFFFFFFFFFFFFFFFF
    return h


def _net_hash(net):
    """Hash a single net's topology and types for per-file caching."""
    h = 5381
    h = _djb2(net["net_name"], h)
    for drv in net["drivers"]:
        h = _djb2(drv["ename"], h)
        h = _djb2(drv.get("type", ""), h)
    for rcv in net["receivers"]:
        h = _djb2(rcv["ename"], h)
        h = _djb2(rcv.get("type", ""), h)
    return h


def _sanitize_id(name):
    """Turn a hierarchical path into a valid VHDL identifier for labels."""
    return name.replace(".", "_").replace(":", "_").replace("@", "").replace(
        "(", "_").replace(")", "_").strip("_")


def _type_info(net):
    """Determine resolution function, vector type, and use clauses for a net.

    Inspects the first driver's type to choose the appropriate resolution
    infrastructure:
      - logic3ds  -> l3ds_resolve / logic3ds_vector  (logic3ds_pkg)
      - logic3d   -> l3d_resolve  / logic3d_vector   (logic3d_types_pkg)
      - std_logic -> resolved     / std_ulogic_vector (std_logic_1164)

    Returns (resolve_func, vec_type, extra_use_clauses).
    """
    if not net["drivers"]:
        return "resolved", "std_ulogic_vector", []

    ep_type = net["drivers"][0]["type"].lower()

    if ep_type == "logic3ds":
        return ("l3ds_resolve", "logic3ds_vector",
                ["use work.logic3ds_pkg.all;"])
    elif ep_type == "logic3d":
        return ("l3d_resolve", "logic3d_vector",
                ["use work.logic3d_types_pkg.all;"])
    else:
        return ("resolved", "std_ulogic_vector", [])


def _gen_net_vhdl(net, idx, design_name, fix_ename):
    """Generate VHDL for a single net's resolver entity.

    Each resolver entity:
      - Reads 'DRIVER signals from tran endpoints on this net
      - Computes per-endpoint 'OTHER (exclude self)
      - Drives the net's port signal with the combined resolved value

    Returns (entity_name, vhdl_string).
    """
    entity_name = f"sv2vhdl_rn_{design_name}_{idx}"
    net_h = _net_hash(net)
    n_ep = len(net["drivers"])
    resolve_func, vec_type, extra_uses = _type_info(net)
    ep_type = net["drivers"][0]["type"].lower() if net["drivers"] else "std_logic"

    lines = []
    lines.append(f"-- Net hash: {net_h:016x}")
    lines.append(f"-- Net: {net['net_name']} ({n_ep} endpoints)")
    lines.append(f"-- Auto-generated by sv2vhdl resolver plugin")
    lines.append(f"")
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    for use in extra_uses:
        lines.append(use)
    lines.append(f"")
    lines.append(f"entity {entity_name} is end;")
    lines.append(f"architecture generated of {entity_name} is")

    # Alias declarations for driver/receiver pairs
    drv_aliases = []
    rcv_aliases = []
    for i in range(n_ep):
        drv = net["drivers"][i]
        rcv = net["receivers"][i]
        da = f"drv_{i}"
        ra = f"rcv_{i}"
        drv_path = fix_ename(drv["ename"])
        rcv_path = fix_ename(rcv["ename"])
        drv_type = drv["type"].lower()
        rcv_type = rcv["type"].lower()
        lines.append(f"    alias {da} is "
                     f"<< signal {drv_path} : {drv_type} >>;")
        lines.append(f"    alias {ra} is "
                     f"<< signal {rcv_path} : {rcv_type} >>;")
        drv_aliases.append(da)
        rcv_aliases.append(ra)

    lines.append(f"begin")

    if n_ep == 1:
        lines.append(f"    -- single endpoint, no resolution needed")
    elif n_ep == 2:
        # Simple swap: each gets the other's driver
        lines.append(f"    {rcv_aliases[0]} <= {drv_aliases[1]};")
        lines.append(f"    {rcv_aliases[1]} <= {drv_aliases[0]};")
    else:
        # N>2: each receiver gets the resolution of all OTHER drivers.
        sens = ", ".join(drv_aliases)
        lines.append(f"    resolve: process({sens})")
        lines.append(f"        variable v : {vec_type}(0 to {n_ep - 2});")
        lines.append(f"    begin")
        for i in range(n_ep):
            others = [drv_aliases[j] for j in range(n_ep) if j != i]
            if len(others) == 1:
                lines.append(f"        {rcv_aliases[i]} <= {others[0]};")
            else:
                for k, other in enumerate(others):
                    lines.append(f"        v({k}) := {other};")
                lines.append(f"        {rcv_aliases[i]} <= {resolve_func}(v);")
        lines.append(f"    end process;")

    lines.append(f"end architecture;")
    lines.append(f"")

    return entity_name, "\n".join(lines)


def resolve_net(nets, design_name):
    """Generate per-net VHDL resolver entities and a wrapper.

    Args:
        nets: list of net dicts (see module docstring)
        design_name: top-level entity name (lowercase)

    Returns:
        dict: {filename: vhdl_string} with one file per net + wrapper,
              or None if nothing to generate.
    """
    if not nets:
        return None

    wrapper_entity = f"resolved_{design_name}"
    dut_label = "dut"

    orig_prefix = f".{design_name}."
    new_prefix = f".{wrapper_entity}.{dut_label}."

    def fix_ename(ename):
        if ename.startswith(orig_prefix):
            return new_prefix + ename[len(orig_prefix):]
        return ename

    files = {}
    entity_names = []

    # Generate one file per net
    for idx, net in enumerate(nets):
        entity_name, vhdl = _gen_net_vhdl(net, idx, design_name, fix_ename)
        filename = f"{design_name}_rn_{idx}.vhd"
        files[filename] = vhdl
        entity_names.append(entity_name)

    # Generate wrapper file
    lines = []
    lines.append(f"-- Wrapper: instantiates DUT + {len(nets)} resolver(s)")
    lines.append(f"-- Auto-generated by sv2vhdl resolver plugin")
    lines.append(f"")
    lines.append(f"library ieee;")
    lines.append(f"use ieee.std_logic_1164.all;")
    lines.append(f"")
    lines.append(f"entity {wrapper_entity} is end;")
    lines.append(f"architecture wrapper of {wrapper_entity} is")
    lines.append(f"begin")
    lines.append(f"    {dut_label}: entity work.{design_name};")
    for idx, ename in enumerate(entity_names):
        lines.append(f"    rn_{idx}: entity work.{ename};")
    lines.append(f"end architecture;")
    lines.append(f"")

    files[f"{design_name}_wrapper.vhd"] = "\n".join(lines)

    return files


# ---------- VHPI exploration helpers ----------

def explore_region(region_path):
    """Explore a design region using VHPI bridge.

    Returns dict with signals, instances, and any power supplies found.
    """
    if not _have_vhpi:
        raise RuntimeError("VHPI bridge not available (not running in simulator)")

    signals = vhpi.get_signals(region_path)
    instances = vhpi.get_instances(region_path)

    # Identify power supply signals by naming convention
    power_signals = {}
    for sig in signals:
        name = sig["name"].upper()
        if name.endswith("_VDD") or name == "VDD":
            power_signals.setdefault("vdd", []).append(sig)
        elif name.endswith("_VSS") or name == "VSS":
            power_signals.setdefault("vss", []).append(sig)

    return {
        "signals": signals,
        "instances": instances,
        "power": power_signals,
    }


def find_power_supplies(net_ename):
    """Find power supply signals in the same scope as a net."""
    if not _have_vhpi:
        return {}

    parent = net_ename.rsplit(".", 1)[0]
    if not parent:
        return {}

    try:
        signals = vhpi.get_signals(parent)
    except (KeyError, RuntimeError):
        return {}

    power = {}
    for sig in signals:
        name = sig["name"].upper()
        if name.endswith("_VDD") or name == "VDD":
            power.setdefault("vdd", []).append(sig)
        elif name.endswith("_VSS") or name == "VSS":
            power.setdefault("vss", []).append(sig)

    return power


def get_instance_generics(instance_ename):
    """Read generics from an instance via VHPI."""
    if not _have_vhpi:
        return {}

    try:
        return vhpi.get_generics(instance_ename)
    except (KeyError, RuntimeError):
        return {}
